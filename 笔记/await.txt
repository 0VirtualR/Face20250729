 ICommand命令的原理是：
当用户点击按钮时，WPF 数据绑定系统会通过按钮的 DataContext（通常继承自其父容器）找到 ViewModel 中对应的命令属性，然后直接触发该命令的 Execute 方法，整个过程基于数据绑定而非命令路由。

INotifyPropertyChanged 的原理是：
当在XAML中绑定ViewModel属性时，WPF绑定系统会建立属性与UI元素之间的关联。当ViewModel中属性值改变并通过PropertyChanged事件通知时，
绑定系统会收到通知，根据属性名找到所有相关的绑定，然后让对应的UI元素重新读取属性值并更新显示。（检查属性是否一致在订阅的事件PropertyChanged 的函数OnPropertyChanged里面）


所以抽象类就是一个有abstract关键字定义，不能被实例化，抽象成员不能是private 或 sealed的类。有抽象方法，虚方法和普通方法。抽象方法必须在子类中实现，虚方法可以选择性的重写。
目的是用来定义对象是什么（身份），提供核心功能的部分实现，强调代码复用。只能内单继承。
接口是使用 interface 关键字声明，定义对象能做什么（行为/能力），强调解耦和多态，不能被实例化，不能包含实例字段，可以多个继承

抽象类其实就是某一类对象的核心功能的部分实现，强调的是代码的复用，只能单继承。而接口则是某一种行为，功能的抽象，强调的是解耦和多态，可以多个继承。


1. 编程范式（Programming Paradigm）
👉 简单说：一种写代码的“哲学”或“方法论”

就像不同的“武功流派”，每种流派有自己独特的招式理念：

OOP（面向对象）：把代码看作互相交互的“对象”（如“订单对象”“用户对象”）

AOP（面向切面）：把日志/权限等横跨多个模块的功能像切蛋糕一样单独抽离

函数式编程：把计算视为数学函数，避免修改变量（如 list.Select(x => x*2)）

2. 编程模型（Programming Model）
👉 简单说：某种范式在具体语言中的实现方式

例如：

OOP 在 C# 中：class、interface、inheritance（继承）

AOP 在 C# 中：用 PostSharp 属性标签 或 Castle.DynamicProxy 动态代理

Lambda 表达式是一种简洁的、用于创建匿名函数的语法。它可以用来代替繁琐的匿名方法或委托定义。
扩展用途：他们允许Lambda表达式在特定的上下文中（即被赋值给 Expression<T> 类型时）被编译成表达式树。

LINQ（Language Integrated Query）的本质是：一套统一的编程模型，用于从各种数据源（内存、数据库、XML等）中查询和操作数据。
目的：让我们能用相同的C#语法去查询不同的数据源

表达式树是一种数据结构，它以树的形式在运行时表示代码逻辑。 它不是可执行的代码，而是代码的抽象表示。
核心目的：动态分析代码逻辑，并将其翻译成其他语言或在其他环境中执行。
表达式树本质上就是一个由一个个结构体或类的实例，通过类似二叉树（或更广义的树形结构）的形式组织起来的数据结构。

代理模式（Proxy Pattern）是一种重要的结构型设计模式，它通过引入代理对象来控制对原始对象的访问，在不改变原始对象代码的前提下增强或控制其功能。
核心思想：使得原始对象专注于核心业务，符合单一职责原则，代理对象负责访问控制和增强功能，延迟了原始对象的创建。


在C#中，​​异步编程​​是一种通过非阻塞方式执行耗时操作（如I/O或计算）的编程范式，其核心目标是提高程序的响应性和资源利用率。
通常通过async/await+task实现以下是异步的定义及关键特性：

​​1. 异步的定义​​
异步（Asynchronous）指程序在执行某个操作时，无需等待其完成即可继续执行其他任务。当操作完成后，通过回调、事件或任务（Task）机制通知程序处理结果。
3. 异步的适用场景​​
​​I/O密集型操作​​：如网络请求、文件读写，通过异步释放线程避免阻塞。
​​UI应用程序​​：保持界面响应，避免主线程卡顿。
​​高并发服务​​：提升服务器吞吐量，例如同时处理多个HTTP请求。
 
仓储模式：仓储模式的主要作用是抽象和封装了数据的访问逻辑，将业务逻辑层和数据访问逻辑分离。器核心思想是将数据访问逻辑封装在一个名为仓储的类中，
该类提供了对数据源的访问接口。业务逻辑层通过调用仓储接口实现数据访问，而无需关注底层数据操作细节。

抽象工厂：创建一系列相关或相互依赖的对象，而无需指定它们具体的类，，核心作用确保 客户端从同一个工厂创建的对象是相互兼容、能协同工作的

1. 工厂模式（Factory Pattern）在 DI 中的应用
GoF 工厂模式定义： 定义一个用于创建对象的接口，但让子类决定实例化哪一个类。其核心作用是通过将对象的创建委托给子类，实现创建逻辑与使用逻辑的解耦。
客户端代码只依赖于产品的抽象接口，而不需要知道具体是哪个类被实例化。这符合“依赖倒置原则”。

在 DI 中的核心作用： 封装单个对象（或简单对象簇）的创建逻辑，隐藏具体实现类的细节。 DI 容器内部大量使用工厂方法来按需创建被注入的对象。

单例模式：确保一个类只有一个实例​​，并提供一个他的全局访问点。

MVVM：MVVM是一种分离UI逻辑和后台业务逻辑而设计的软件架构，其核心思想是通过数据绑定实现视图和视图模型的自动同步。


依赖注入（Dependency Injection，DI）是netcore中解耦组件依赖关系的核心技术，他将对象的 创建从对象内部移交给外部容器，而不是由对象内部自行创建依赖关系，实现了控制反转（核心）。

泛型定义：通过引入类型参数（如T、E、K等），使得类、接口或方法可以操作多种数据类型，而无需为每种类型重复编写代码  ，总结就是：类型参数化。
泛型（Generics）是程序设计语言中的一种特性，允许在编写代码时使用​​类型参数化​​，从而延迟具体类型的指定，直到实际使用时才确定。
其核心目的是提高代码的​​复用性​​（无需为每种类型单独实现）、​​类型安全性（泛型在​​编译时​​进行类型检查，消除运行时因类型不匹配导致的错误）​​和​​运行效率​​，（避免值类型的装箱/拆箱，代码复用​​）。

反射是 C# 中一个强大的功能，它允许程序在运行时检查、分析和操作类型信息。通过反射，你可以动态地获取类型信息、创建对象、调用方法、访问字段和属性等，
而不需要在编译时知道这些类型的具体细节。

，过滤器（Filters） 是一种在 ASP.NET Core 的请求处理管道中运行代码的机制。
它们允许你在请求处理的不同阶段（如授权、资源管理、动作执行、结果处理）插入自定义逻辑，实现横切关注点

Prism的EventAggregator本质是​​支持一对多通信的观察者模式实现​​。你的“一对一”感受源于当前使用场景的订阅者数量，而非框架限制。
通过增加订阅者或跨模块设计，即可体现其“一对多”能力。

1. 观察者模式 (Observer Pattern)
定义：
定义对象间的一种一对多的依赖关系，当一个对象（Subject）状态发生改变时，所有依赖它的对象（Observers）都会自动收到通知并更新。

WPF/MVVM中的典型应用：
在MVVM中，当ViewModel的属性值发生变化时（例如用户输入或数据加载完成），
通过INotifyPropertyChanged接口触发通知，所有绑定到该属性的UI控件（如TextBox、Label）会自动更新，无需手动操作UI元素。
EventAggregator（Prism）：
用于跨模块通信，例如当模块A发布“数据已保存”事件后，模块B和模块C的订阅者会自动刷新列表或显示提示消息，而模块A无需直接引用B/C。

本质：
ViewModel作为被观察者（Subject），View的绑定控件作为观察者（Observer），实现数据变化到UI的自动同步。

2. 命令模式 (Command Pattern)
定义：
将请求封装为独立的对象（Command），包含执行操作的所有信息，支持请求的排队、日志、撤销等操作。

WPF/MVVM中的典型应用：
通过ICommand接口（如DelegateCommand）将按钮点击、右键菜单等UI操作封装为命令对象，
	ViewModel只需暴露命令属性，View通过XAML绑定即可触发业务逻辑，彻底消除后台代码中的事件处理程序。
CompositeCommand（Prism）：
例如同时执行“保存表单”、“记录日志”、“关闭窗口”等多个命令，而无需修改原有命令逻辑。

本质：
将UI操作从事件处理程序中解耦，转变为可绑定、可组合的对象。


3. 装饰器模式 (Decorator Pattern)
定义：
动态地给一个对象添加额外职责，提供比继承更灵活的扩展方式。

WPF/MVVM中的典型应用：
通过控件模板（ControlTemplate）或附加行为（Behaviors）动态扩展WPF控件的功能，例如为原生Button添加圆角、悬浮动画，或为TextBox添加自动验证逻辑，而无需创建子类或修改控件源码。
数据验证装饰：
通过实现IDataErrorInfo接口，为原始数据模型动态添加验证规则，例如验证用户名是否为空或重复，而模型类无需包含验证代码。

本质：
通过嵌套包装（如WPF的Decorator基类）在运行时增强对象功能，避免静态继承的僵化。


适配器模式 (Adapter Pattern)
定义：
将一个类的接口转换成客户端期望的另一种接口，使原本不兼容的类可以协同工作。

WPF/MVVM中的典型应用：
在数据绑定场景中，适配器模式通过IValueConverter接口解决数据模型（如DateTime、枚举值）与UI显示格式（如"yyyy-MM-dd"、描述性文字）之间的类型或格式不匹配问题，无需修改原始数据模型即可满足前端展示需求。

1. 数据转换（IValueConverter）
核心作用：
将数据源的原始值（如枚举、日期、数值）动态转换为UI可直接显示的格式（如字符串、颜色、可见性）。

典型场景：

日期时间格式化（DateTime → "2023-01-01"）

枚举值转描述文本（OrderStatus.Pending → "待处理"）

布尔值转控件可见性（true → Visibility.Visible）